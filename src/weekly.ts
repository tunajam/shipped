import * as fs from 'fs';
import * as core from '@actions/core';
import OpenAI from 'openai';
import type { GitHub } from '@actions/github/lib/utils';
import type { Context } from '@actions/github/lib/context';
import type { AIConfig } from './index';

interface GenerateWeeklyOptions {
  octokit: InstanceType<typeof GitHub>;
  context: Context;
  aiConfig: AIConfig;
  changelogPath: string;
  weeklyPath: string;
}

interface WeekEntry {
  date: string;
  content: string;
}

export async function generateWeeklyDigest(options: GenerateWeeklyOptions): Promise<string> {
  const { aiConfig, changelogPath, weeklyPath } = options;

  core.info('Generating weekly digest...');

  // Parse this week's entries from CHANGELOG.md
  const entries = parseThisWeeksEntries(changelogPath);
  
  if (entries.length === 0) {
    core.info('No entries found for this week. Skipping digest.');
    return '';
  }

  core.info(`Found ${entries.length} entries for this week`);

  // Generate digest using AI
  const digest = await generateDigestWithAI(entries, aiConfig);
  
  // Write to WEEKLY.md
  await writeWeeklyDigest(digest, weeklyPath);
  
  return digest;
}

function parseThisWeeksEntries(changelogPath: string): WeekEntry[] {
  if (!fs.existsSync(changelogPath)) {
    return [];
  }

  const content = fs.readFileSync(changelogPath, 'utf-8');
  
  // Get date range for this week (last 7 days)
  const now = new Date();
  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  
  const entries: WeekEntry[] = [];
  
  // Parse entries by date header (## YYYY-MM-DD)
  const entryRegex = /## (\d{4}-\d{2}-\d{2})\n([\s\S]*?)(?=\n## \d{4}-\d{2}-\d{2}|$)/g;
  
  let match;
  while ((match = entryRegex.exec(content)) !== null) {
    const dateStr = match[1];
    const entryContent = match[2].trim();
    const entryDate = new Date(dateStr);
    
    if (entryDate >= weekAgo && entryDate <= now) {
      entries.push({
        date: dateStr,
        content: entryContent,
      });
    }
  }

  return entries;
}

async function generateDigestWithAI(entries: WeekEntry[], aiConfig: AIConfig): Promise<string> {
  const openai = new OpenAI({ 
    apiKey: aiConfig.apiKey,
    baseURL: aiConfig.baseURL,
  });

  const entriesText = entries
    .map(e => `### ${e.date}\n${e.content}`)
    .join('\n\n');

  // Extract contributors from entries
  const contributorMatches = entriesText.matchAll(/@(\w+)/g);
  const contributors = [...new Set([...contributorMatches].map(m => m[1]))];

  const response = await openai.chat.completions.create({
    model: aiConfig.model,
    messages: [
      {
        role: 'system',
        content: `You are a technical writer creating an engaging weekly digest of software updates.

Your digest should:
- Tell a story about what the team accomplished this week
- Group related changes into themes
- Highlight the most impactful changes
- Celebrate contributors
- Use emoji to make it scannable

HUMANIZER RULES â€” Avoid AI-sounding patterns:
- No corporate speak: Skip "We're excited to announce", "proud to share"
- No puffery: Cut "incredible", "amazing", "game-changing", "groundbreaking"
- No filler: Skip "In this update", "As always", "Moving forward"
- Be direct: "This week: dark mode, faster loads, bug fixes" not "This week we're thrilled to bring you..."
- Sound human: Write like you're updating a friend, not a press release
- Vary sentence length: Short punchy. Then explain more when needed.
- Be specific: Numbers and details beat vague praise

The goal is a digest that feels like it was written by a person who actually built this stuff.

Output a complete weekly digest in markdown format.`,
      },
      {
        role: 'user',
        content: `Create a weekly digest from these changelog entries:

${entriesText}

Contributors this week: ${contributors.map(c => `@${c}`).join(', ')}

Write an engaging summary that:
1. Opens with a brief overview of the week's focus
2. Has a "Highlights" section with the top 3-5 changes
3. Has a "Contributors" section thanking everyone
4. Ends with a forward-looking sentence`,
      },
    ],
    temperature: 0.7,
    max_tokens: 1000,
  });

  const content = response.choices[0]?.message?.content;
  if (!content) {
    throw new Error('No response from OpenAI');
  }

  return formatWeeklyDigest(content);
}

function formatWeeklyDigest(aiContent: string): string {
  const now = new Date();
  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  
  const formatDate = (d: Date) => d.toLocaleDateString('en-US', { 
    month: 'long', 
    day: 'numeric',
    year: 'numeric'
  });

  const weekRange = `${formatDate(weekAgo)} - ${formatDate(now)}`;

  return `# Week of ${weekRange}

${aiContent.trim()}

---

*Generated by [Shipped](https://github.com/tunajam/shipped)*
`;
}

async function writeWeeklyDigest(digest: string, weeklyPath: string): Promise<void> {
  // For WEEKLY.md, we overwrite (it's always the current week)
  // But we could also archive to weekly/YYYY-MM-DD.md
  
  fs.writeFileSync(weeklyPath, digest, 'utf-8');
  core.info(`Updated ${weeklyPath}`);
}
